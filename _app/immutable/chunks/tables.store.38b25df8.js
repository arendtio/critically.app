var S=(h,t,e)=>{if(!t.has(h))throw TypeError("Cannot "+e)};var s=(h,t,e)=>(S(h,t,"read from private field"),e?e.call(h):t.get(h)),p=(h,t,e)=>{if(t.has(h))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(h):t.set(h,e)},w=(h,t,e,r)=>(S(h,t,"write to private field"),r?r.call(h,e):t.set(h,e),e);var I=(h,t,e)=>(S(h,t,"access private method"),e);import{w as F}from"./index.9f5fd596.js";import{E as T}from"./scheduler.d96d3362.js";var i,m,f,x,R,C,$;const E=class E{constructor(t=[],e="Id"){p(this,x);p(this,C);p(this,i,void 0);p(this,m,void 0);p(this,f,void 0);if(w(this,f,e),!Array.isArray(t))throw new Error("Headers must be an array");if(w(this,i,[]),t.length>0){if(!t.includes(s(this,f)))throw new Error(`Id column '${s(this,f)}' must be included in headers`);w(this,i,[t]),w(this,m,[...t])}else w(this,m,[])}getIdColumnName(){return s(this,f)}getIdColumnIndex(){return s(this,i)[0].indexOf(s(this,f))}getHeader(){return s(this,i).length===0?[]:[...s(this,i)[0]]}changeHeadings(t){if(!Array.isArray(t))throw new Error("New headings must be an array");if(s(this,i).length===0){if(t.includes(s(this,f)))s(this,i)[0]=[...t];else throw new Error(`Id column '${s(this,f)}' must be included in headers`);return this}const r=this.getHeader().length;if(t.length!==r)throw new Error("New headings must have the same length as current headings");if(!t.includes(s(this,f)))throw new Error(`Id column '${s(this,f)}' must be included in headers`);return s(this,i)[0]=[...t],this}getAllIds(){const t=this.getIdColumnIndex();return t===-1?(console.error(`Id column '${s(this,f)}' not found in table headers`),[]):s(this,i).slice(1).map(e=>String(e[t]))}getRow(t){const e=I(this,x,R).call(this,t);return e===-1?[]:[...s(this,i)[e]]}toJSON(){return Array.isArray(s(this,i))?s(this,i):[s(this,m)]}clone(){const t=new E(s(this,m),s(this,f)),e=this.toJSON();return t.restore(e),t}setFrom(t){if(!(t instanceof E))throw new Error("Source must be a Table instance");const e=t.toJSON();return this.restore(e),this}static fromJSON(t,e="Id"){const r=JSON.parse(t),n=new E(r[0],e);return n.restore(r),n}restore(t){if(!Array.isArray(t))return console.error("Invalid data format for restore:",t),w(this,i,[s(this,m)]),this;try{const e=Array.isArray(t[0])?[...t[0]]:[...s(this,m)];w(this,i,[e]);for(let r=1;r<t.length;r++)Array.isArray(t[r])&&s(this,i).push([...t[r]]);return w(this,m,[...s(this,i)[0]]),this}catch(e){return console.error("Error copying existing rows:",e),w(this,i,[s(this,m)]),this}}add_rows(t,e=null){for(const r of t){if(r.length!==s(this,i)[0].length)throw new Error("Row must match header length");const n=this.getIdColumnIndex(),o=r[n];if(I(this,x,R).call(this,o)!==-1)throw new Error(`Row with Id ${o} already exists`)}if(e){const r=I(this,x,R).call(this,e);if(r===-1)throw new Error(`Row with Id ${e} not found`);s(this,i).splice(r+1,0,...t.map(n=>[...n]))}else t.forEach(r=>s(this,i).push([...r]));return this}replace_rows(t){for(const e of t){if(e.length!==s(this,i)[0].length)throw new Error("Row must match header length");const r=this.getIdColumnIndex(),n=e[r],o=I(this,x,R).call(this,n);if(o===-1)throw new Error(`Row with Id ${n} does not exist. Use add_rows to add new rows.`);s(this,i)[o]=[...e]}return this}delete_rows(t){if(!Array.isArray(t))throw new Error("IDs must be an array");return t.map(r=>I(this,x,R).call(this,r)).filter(r=>r!==-1).sort((r,n)=>n-r).forEach(r=>{s(this,i).splice(r,1)}),this}delete_row(t){return this.delete_rows([t])}clear_table(){return w(this,i,[s(this,m)]),this}add_or_replace_columns(t,e){if(!Array.isArray(t)||!Array.isArray(e))throw new Error("Column names and values must be arrays");if(t.length!==e.length)throw new Error("Number of column names must match number of value arrays");return t.forEach((r,n)=>{const o=e[n];if(!Array.isArray(o)||o.length===0||o[0]!==r)throw new Error("Each value array must start with its column name");const d=s(this,i).length-1;if(o.length-1!==d)throw new Error(`Column values must match number of rows (${d})`);let l=I(this,C,$).call(this,r);if(l===-1){l=s(this,i)[0].length,s(this,i)[0].push(r);for(let u=1;u<s(this,i).length;u++){const c=o[u];s(this,i)[u].push(c||"")}}else for(let u=0;u<d;u++){s(this,i)[u+1][l];const c=o[u+1];c!==""&&(s(this,i)[u+1][l]=c)}}),this}delete_column(t){if(t===s(this,f))throw new Error(`Cannot delete the Id column (${s(this,f)})`);const e=I(this,C,$).call(this,t);if(e===-1)throw console.error("Error: Column does not exist"),new Error("Column does not exist");return w(this,i,s(this,i).map(r=>{const n=[...r];return n.splice(e,1),n})),w(this,m,s(this,i)[0]),this}};i=new WeakMap,m=new WeakMap,f=new WeakMap,x=new WeakSet,R=function(t){const e=this.getIdColumnIndex();if(e===-1)return console.error(`Id column '${s(this,f)}' not found in table headers`),-1;for(let r=1;r<s(this,i).length;r++)if(String(s(this,i)[r][e])===String(t))return r;return console.log(`Row with Id ${t} not found in table with ${s(this,i).length} rows`),console.log(`Table headers: ${s(this,i)[0]}`),s(this,i).length>1&&console.log(`First row: ${s(this,i)[1]}`),-1},C=new WeakSet,$=function(t){return s(this,i)[0].indexOf(t)};let O=E;var y,A,L;const H=class H extends O{constructor(e=[],r="Id",n="_level"){Array.isArray(e)&&e.length>0&&!e.includes(n)&&(e=[...e,n]);super(e,r);p(this,A);p(this,y,void 0);w(this,y,n)}getLevelColumnName(){return s(this,y)}getRowLevel(e){const r=this.getRow(e);if(r.length===0)return null;const n=I(this,A,L).call(this);if(n===-1)return 1;const o=Number(r[n]);return isNaN(o)?1:o}setRowLevel(e,r){if(typeof r!="number"||r<1)throw new Error("Level must be a positive number");const n=I(this,A,L).call(this);if(n===-1)throw new Error(`Level column '${s(this,y)}' not found`);const o=this.getRow(e);if(o.length===0)throw new Error(`Row with Id ${e} not found`);const d=[...o];return d[n]=r,this.replace_rows([d]),this}getChildren(e){const r=this.getAllIds(),n=r.indexOf(e);if(n===-1)return[];const o=this.getRowLevel(e),d=o+1,l=[];let u=!0;for(let c=n+1;c<r.length&&u;c++){const a=r[c],g=this.getRowLevel(a);g<=o?u=!1:g===d&&l.push(a)}return l}getAllChildren(e){const r=this.getAllIds(),n=r.indexOf(e);if(n===-1)return[];const o=this.getRowLevel(e),d=[];let l=!0;for(let u=n+1;u<r.length&&l;u++){const c=r[u];this.getRowLevel(c)<=o?l=!1:d.push(c)}return d}getParent(e){const r=this.getAllIds(),n=r.indexOf(e);if(n===-1)return null;const o=this.getRowLevel(e);if(o<=1)return null;const d=o-1;for(let l=n-1;l>=0;l--){const u=r[l],c=this.getRowLevel(u);if(c===d)return u;if(c<d)break}return null}delete_row_with_children(e){const r=this.getAllChildren(e),n=[e,...r];return this.delete_rows(n),this}ensureValidLevel(e){const r=I(this,A,L).call(this);if(r===-1)return e;const n=e[r];if(n==null||n===""){const o=[...e];return o[r]=1,o}return e}add_rows(e,r=null){const n=e.map(o=>this.ensureValidLevel(o));return super.add_rows(n,r)}replace_rows(e){const r=e.map(n=>this.ensureValidLevel(n));return super.replace_rows(r)}clone(){const e=new H(this.getHeader(),this.getIdColumnName(),s(this,y)),r=this.toJSON();return e.restore(r),e}};y=new WeakMap,A=new WeakSet,L=function(){return this.getHeader().indexOf(s(this,y))};let b=H;const V=new Map;function k(h,t,e="Id"){let r=new b(t,e);V.set(h,F(r))}function P(h){return V.get(h)}function q(h){const t=new Set;if(!h)return console.error("Invalid tasksTable object:",h),[];const e=h.getAllIds(),n=h.getHeader().indexOf("Resources");if(n===-1)for(const d of e){const l=h.getRow(d);if(l&&l.length>5){const u=String(l[5]||"");if(u.trim()){const c=u.split(/[,&]/).map(a=>a.trim()).filter(a=>a.length>0);for(const a of c)t.add(a)}}}else for(const d of e){const l=h.getRow(d);if(!Array.isArray(l)||l.length===0)continue;if(l.length<=n){console.log(`Row too short (${l.length}), needs at least ${n+1} elements:`,JSON.stringify(l));continue}const u=String(l[n]||"");if(u.trim()){const c=u.split(/[,&]/).map(a=>a.trim()).filter(a=>a.length>0);for(const a of c)t.add(a)}}return Array.from(t)}function M(h,t){try{const e=q(h),r=T(t),n=r.getHeader();let o=[];const d=n.filter(c=>c!=="Id"&&c!=="_level");if(!d.includes("Date")&&!e.includes("Date"))o=["Date",...e];else if(d.includes("Date")){const c=d.indexOf("Date");o=[...d],o=o.filter(g=>g==="Date"||e.includes(g));const a=new Set(o);for(const g of e)a.has(g)||o.push(g)}else{const c=e.indexOf("Date");c!==-1?(e.splice(c,1),o=["Date",...e]):o=["Date",...e]}const l=new b(o,"Date"),u=r.getAllIds();for(const c of u){const a=r.getRow(c);if(!a||a.length===0)continue;const g=[];for(let v=0;v<o.length;v++){const J=o[v],N=n.indexOf(J);J==="Date"?g.push(c):N!==-1&&N<a.length?g.push(a[N]):g.push("")}let _=1;const D=n.indexOf("_level");if(D!==-1&&D<a.length){const v=a[D];v&&!isNaN(Number(v))&&(_=Number(v))}l.add_rows([g]),_!==1&&l.setRowLevel(c,_)}if(u.length===0&&e.length>0){const a=[new Date().toISOString().split("T")[0],...Array(e.length).fill("")];l.add_rows([a])}return t.set(l),l}catch(e){return console.error("Error updating resources table:",e),T(t)}}const U=["_level","Id","Task","Min","Likely","Max","Resources","Predecessors","Progress","Start","Deadline"];k("tasks",U,"Id");const z=["Date"];k("resources",z,"Date");const B=P("tasks"),G=P("resources");B.subscribe(h=>{try{M(h,G)}catch(t){console.error("Error in tasks subscription:",t)}});export{b as T,P as g};
