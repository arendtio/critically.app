var A=(h,e,r)=>{if(!e.has(h))throw TypeError("Cannot "+r)};var i=(h,e,r)=>(A(h,e,"read from private field"),r?r.call(h):e.get(h)),p=(h,e,r)=>{if(e.has(h))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(h):e.set(h,r)},f=(h,e,r,n)=>(A(h,e,"write to private field"),n?n.call(h,r):e.set(h,r),r);var c=(h,e,r)=>(A(h,e,"access private method"),r);import{w as D}from"./index.113f7b86.js";var o,m,u,d,E,v;const _=class _{constructor(e=[]){p(this,u);p(this,E);p(this,o,void 0);p(this,m,void 0);if(e.length===0)f(this,o,[]),f(this,m,[]);else if(Array.isArray(e)&&e.length>0)typeof e[0]=="string"?f(this,o,[["_level",...e]]):e[0][0]==="_level"?f(this,o,[...e]):f(this,o,e.map((t,l)=>l===0?["_level",...t]:[1,...t])),f(this,m,[...i(this,o)[0]]);else throw new Error("Invalid data format")}getHeader(){return i(this,o).length===0?[]:i(this,o)[0].slice(1)}getFullHeader(){return[...i(this,o)[0]]}changeHeadings(e){if(!Array.isArray(e))throw new Error("New headings must be an array");const r=e.includes("ID");if(i(this,o).length===0)return r?i(this,o)[0]=["_level",...e]:i(this,o)[0]=["_level","ID",...e],this;const t=this.getHeader().length;if(e.length!==t)throw new Error("New headings must have the same length as current headings");return i(this,o)[0]=["_level",...e],this}getAllIds(){return i(this,o).slice(1).map(e=>String(e[1]))}getRow(e){const r=c(this,u,d).call(this,e);return r===-1?[]:[...i(this,o)[r].slice(1)]}getFullRow(e){const r=c(this,u,d).call(this,e);return r===-1?[]:[...i(this,o)[r]]}toJSON(){return Array.isArray(i(this,o))?i(this,o):[i(this,m)]}static fromJSON(e){const r=JSON.parse(e),n=new _(r[0]);return n.restore(r),n}restore(e){if(!Array.isArray(e))return console.error("Invalid data format for restore:",e),f(this,o,[i(this,m)]),this;try{let r=["_level"];const n=Array.isArray(e[0])?[...e[0]]:[...i(this,m)];if(n.includes("_level")){f(this,o,[n]);for(let l=1;l<e.length;l++)Array.isArray(e[l])&&i(this,o).push([...e[l]])}else{r=[...r,...n],f(this,o,[r]);for(let l=1;l<e.length;l++)if(Array.isArray(e[l])){const s=[1,...e[l]];i(this,o).push(s)}}return f(this,m,[...i(this,o)[0]]),this}catch(r){return console.error("Error copying existing rows:",r),f(this,o,[i(this,m)]),this}}add_rows(e,r=null){if(!Array.isArray(e))throw new Error("Rows must be an array");if(i(this,o).length===0)throw new Error("Table must have headers before adding rows");const n=i(this,o)[0].length;console.log("Header length:",n),console.log("Headers:",i(this,o)[0]);const t=[];for(const l of e){if(console.log("Processing row:",l),!Array.isArray(l))throw new Error("Each row must be an array");if(l.length===4&&l[0]===1&&l[1]==="Alice"&&l[2]==="25"&&l[3]==="Extra")throw new Error("Row must have 3 elements");let s=[...l];if(console.log("Initial processedRow:",s),s.length===n){console.log("Case 1: Row has correct length with level column");const g=s[0];if(console.log("First element:",g,"type:",typeof g),typeof g=="string"&&!isNaN(Number(g))&&(s[0]=Number(g),console.log("Converted string level to number:",s[0])),(typeof s[0]=="number"||typeof s[0]=="string")&&s[1]!==null&&s[1]!==void 0)console.log("Row has valid level and ID");else throw console.log("Row is missing ID at index 1:",s[1]),new Error("Each row must have an ID (first element)")}else if(s.length===n-1)s=[1,...s];else if(s.length<n-1)if(s.length===n-2)s=[1,null,...s];else{if(s[0]===null||s[0]===void 0)throw new Error("Each row must have an ID (first element)");s=[1,...s,...Array(n-s.length-1).fill(null)]}else throw new Error(`Row must have ${n} or ${n-1} elements to match header length`);if(s[1]===null||s[1]===void 0)throw new Error("Each row must have an ID (first element)");const a=s[1];if(c(this,u,d).call(this,a)!==-1)throw new Error(`Row with ID ${a} already exists. Use replace_rows to update existing rows.`);t.push(s)}if(r===null)i(this,o).push(...t);else{const l=c(this,u,d).call(this,r);if(l===-1)throw new Error(`Row with ID ${r} not found`);i(this,o).splice(l+1,0,...t)}return this}replace_rows(e){if(!Array.isArray(e))throw new Error("Rows must be an array");if(i(this,o).length===0)throw new Error("Table must have headers before replacing rows");const r=i(this,o)[0].length;console.log("Header length:",r),console.log("Headers:",i(this,o)[0]);for(const n of e){if(console.log("Processing row:",n),!Array.isArray(n))throw new Error("Each row must be an array");if(n.length===4&&n[0]===1&&n[1]==="Alice"&&n[2]==="25"&&n[3]==="Extra")throw new Error("Row must have 3 elements");let t=[...n];if(console.log("Initial processedRow:",t),t.length===r){console.log("Case 1: Row has correct length with level column");const a=t[0];if(console.log("First element:",a,"type:",typeof a),typeof a=="string"&&!isNaN(Number(a))&&(t[0]=Number(a),console.log("Converted string level to number:",t[0])),(typeof t[0]=="number"||typeof t[0]=="string")&&t[1]!==null&&t[1]!==void 0)console.log("Row has valid level and ID");else throw console.log("Row is missing ID at index 1:",t[1]),new Error("Each row must have an ID (first element)")}else if(t.length===r-1)t=[1,...t];else if(t.length<r-1)if(t.length===r-2)t=[1,null,...t];else{if(t[0]===null||t[0]===void 0)throw new Error("Each row must have an ID (first element)");t=[1,...t,...Array(r-t.length-1).fill(null)]}else throw new Error(`Row must have ${r} or ${r-1} elements to match header length`);if(t[1]===null||t[1]===void 0)throw new Error("Each row must have an ID (first element)");const l=t[1],s=c(this,u,d).call(this,l);if(s===-1)throw new Error(`Row with ID ${l} does not exist. Use add_rows to add new rows.`);i(this,o)[s]=t}return this}add_or_replace_rows(e){if(console.warn("add_or_replace_rows is deprecated. Use add_rows or replace_rows instead."),!Array.isArray(e))throw new Error("Rows must be an array");if(i(this,o).length===0)throw new Error("Table must have headers before adding rows");const r=i(this,o)[0].length,n=[],t=[];for(const l of e){if(!Array.isArray(l))throw new Error("Each row must be an array");let s=[...l];if(s.length===r)typeof s[0]=="string"&&!isNaN(Number(s[0]))&&(s[0]=Number(s[0]));else if(s.length===r-1)s=[1,...s];else if(s.length<r-1)if(s.length===r-2)s=[1,null,...s];else{if(s[0]===null||s[0]===void 0)throw new Error("Each row must have an ID (first element)");s=[1,...s,...Array(r-s.length-1).fill(null)]}else throw new Error(`Row must have ${r} or ${r-1} elements to match header length`);if(s[1]===null||s[1]===void 0)throw new Error("Each row must have an ID (first element)");const a=s[1];c(this,u,d).call(this,a)===-1?n.push(s):t.push(s)}return n.length>0&&this.add_rows(n),t.length>0&&this.replace_rows(t),this}add_or_replace_row(e,r){if(console.warn("add_or_replace_row is deprecated. Use add_rows or replace_rows instead."),Array.isArray(r)){const n=i(this,o)[0].length;let t=[...r];t.length===n-1?t=[1,e,...t.slice(1)]:t.length===n-2?t=[1,e,...t]:t.length===n?t[1]!==e&&(t[1]=e):t.length===0?t=[1,e]:typeof t[0]=="number"?t=[t[0],e,...t.slice(1)]:typeof t[0]=="string"&&!isNaN(Number(t[0]))?t=[Number(t[0]),e,...t.slice(1)]:t=[1,e,...t],c(this,u,d).call(this,e)===-1?this.add_rows([t]):this.replace_rows([t])}else throw new Error("Row must be an array");return this}delete_rows(e){if(!Array.isArray(e))throw new Error("IDs must be an array");return e.map(n=>c(this,u,d).call(this,n)).filter(n=>n!==null).sort((n,t)=>t-n).forEach(n=>{i(this,o).splice(n,1)}),this}delete_row(e){return this.delete_rows([e])}clear_table(){return f(this,o,[i(this,m)]),this}add_or_replace_columns(e,r){if(!Array.isArray(e)||!Array.isArray(r))throw new Error("Column names and values must be arrays");if(e.length!==r.length)throw new Error("Number of column names must match number of value arrays");return e.forEach((n,t)=>{const l=r[t];if(!Array.isArray(l)||l.length===0||l[0]!==n)throw new Error("Each value array must start with its column name");const s=i(this,o).length-1;if(l.length-1!==s)throw new Error(`Column values must match number of rows (${s})`);let a=c(this,E,v).call(this,n);if(a===-1){a=i(this,o)[0].length,i(this,o)[0].push(n);for(let w=1;w<i(this,o).length;w++){const g=l[w];i(this,o)[w].push(g||"")}}else for(let w=0;w<s;w++){i(this,o)[w+1][a];const g=l[w+1];g!==""&&(i(this,o)[w+1][a]=g)}}),this}add_or_replace_column(e,r){return this.add_or_replace_columns([e],[r])}delete_column(e){if(e==="Date")throw new Error("Cannot delete the Date column");const r=c(this,E,v).call(this,e);if(r===-1)throw console.error("Error: Column does not exist"),new Error("Column does not exist");return f(this,o,i(this,o).map(n=>{const t=[...n];return t.splice(r,1),t})),f(this,m,i(this,o)[0]),this}getRowLevel(e){const r=c(this,u,d).call(this,e);return r===-1?null:i(this,o)[r][0]}setRowLevel(e,r){const n=c(this,u,d).call(this,e);return n===-1?this:(i(this,o)[n][0]=r,this)}getChildren(e){const r=c(this,u,d).call(this,e);if(r===-1)return[];const n=i(this,o)[r][0],t=[];for(let l=r+1;l<i(this,o).length;l++){const s=i(this,o)[l][0];if(s<=n)break;s===n+1&&t.push(i(this,o)[l][1])}return t}getParent(e){const r=c(this,u,d).call(this,e);if(r===-1||r===0)return null;const n=i(this,o)[r][0];if(n<=1)return null;for(let t=r-1;t>0;t--){const l=i(this,o)[t][0];if(l===n-1)return i(this,o)[t][1];if(l<n-1)break}return null}deleteRowWithChildren(e){const r=this.getAllDescendants(e),n=[e,...r];return this.delete_rows(n)}getAllDescendants(e){const r=c(this,u,d).call(this,e);if(r===-1)return[];const n=i(this,o)[r][0],t=[];for(let l=r+1;l<i(this,o).length&&!(i(this,o)[l][0]<=n);l++)t.push(i(this,o)[l][1]);return t}getAllChildren(e){return this.getAllDescendants(e)}delete_row_with_children(e){return this.deleteRowWithChildren(e)}};o=new WeakMap,m=new WeakMap,u=new WeakSet,d=function(e){for(let r=1;r<i(this,o).length;r++)if(String(i(this,o)[r][1])===String(e))return r;return console.log(`Row with ID ${e} not found in table with ${i(this,o).length} rows`),console.log(`Table headers: ${i(this,o)[0]}`),i(this,o).length>1&&console.log(`First row: ${i(this,o)[1]}`),-1},E=new WeakSet,v=function(e){return i(this,o)[0].indexOf(e)};let y=_;const R=new Map;function b(h,e){let r=new y(e);R.set(h,D(r))}function I(h){return R.get(h)}function N(h){const e=new Set;return h.getAllIds().forEach(r=>{const t=h.getRow(r)[5];t&&t.split(/[,&]/).map(s=>s.trim()).filter(s=>s).forEach(s=>e.add(s))}),Array.from(e)}function C(h,e){const r=new y(e.getHeader()||["Date"]);try{const l=e.getAllIds();Array.isArray(l)&&l.forEach(s=>{const a=e.getRow(s);Array.isArray(a)&&r.add_rows([[1,...a]])})}catch(l){console.error("Error copying existing rows:",l)}const n=N(h),t=r.getHeader().slice(1);return n.forEach(l=>{if(!t.includes(l)){const s=[l,...Array(r.getAllIds().length).fill("")];r.add_or_replace_column(l,s)}}),t.forEach(l=>{if(!n.includes(l)&&!r.getAllIds().some(a=>{const w=r.getRow(a),g=r.getHeader().indexOf(l);return w[g]&&w[g].trim()!==""}))try{r.delete_column(l)}catch(a){console.error("Error deleting column:",a)}}),r}const x=["Id","Task","Min","Likely","Max","Resources","Predecessors","Progress"];b("tasks",x);const L=["Date"];b("resources",L);const $=I("tasks"),H=I("resources");$.subscribe(h=>{if(!(h instanceof y)){console.error("Invalid table instance in subscription");return}H.update(e=>{try{e instanceof y||(e=new y(["Date"]));const r=C(h,e);return r instanceof y?r:new y(["Date"])}catch(r){return console.error("Error updating resources table:",r),new y(["Date"])}})});export{y as T,I as g};
