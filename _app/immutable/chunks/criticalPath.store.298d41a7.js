var M=(i,e,s)=>{if(!e.has(i))throw TypeError("Cannot "+s)};var c=(i,e,s)=>(M(i,e,"read from private field"),s?s.call(i):e.get(i)),h=(i,e,s)=>{if(e.has(i))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(i):e.set(i,s)},m=(i,e,s,t)=>(M(i,e,"write to private field"),t?t.call(i,s):e.set(i,s),s);var p=(i,e,s)=>(M(i,e,"access private method"),s);import{w as L}from"./index.2391f01a.js";var o,d,u,S,E,O,f,v,P,F,C,T;class R{constructor(){h(this,E);h(this,f);h(this,P);h(this,C);h(this,o,void 0);h(this,d,[]);h(this,u,[]);h(this,S,void 0);m(this,o,new Map),m(this,S,new Map)}addTask(e,s,t,r,a,l,n,N){t=y(t),r=y(r),a=y(a),l=l.split(",").map(g=>g.split("&").map(J=>J.trim())),n=n.split(",").map(g=>g.trim()).filter(g=>g!=="");let A=Math.round((t+r*4+a)/6),G={id:e,name:s,min:t,likely:r,max:a,res:l,resIdList:[],predecessors:new Set(n),successors:new Set,progress:N,earlyCol:1,es:0,ef:0,ls:0,lf:0,slack:-1,expected:A};c(this,o).set(e,G)}getTask(e){return c(this,o).get(e)}calc(){return p(this,E,O).call(this),p(this,P,F).call(this),p(this,C,T).call(this),{starts:c(this,d),map:Object.fromEntries(c(this,o)),ends:c(this,u)}}}o=new WeakMap,d=new WeakMap,u=new WeakMap,S=new WeakMap,E=new WeakSet,O=function(){c(this,o).forEach(e=>{e.predecessors.forEach(s=>{c(this,o).get(s).successors.add(e.id)})}),m(this,d,[...c(this,o).values()].filter(e=>e.predecessors.size===0).map(e=>e.id)),m(this,u,[...c(this,o).values()].filter(e=>e.successors.size===0).map(e=>e.id))},f=new WeakSet,v=function(e,s,t,r){if(t.has(e))return;t.add(e);let a=c(this,o).get(e);a[s].forEach(l=>{p(this,f,v).call(this,l,s,t,r)}),a=r(a),c(this,o).set(a.id,a)},P=new WeakSet,F=function(){let e=new Set;c(this,u).forEach(s=>{p(this,f,v).call(this,s,"predecessors",e,t=>{let r=[...t.predecessors].map(l=>c(this,o).get(l)).reduce((l,n)=>l<n.ef?n.ef:l,0),a=[...t.predecessors].map(l=>c(this,o).get(l)).reduce((l,n)=>l<n.earlyCol?n.earlyCol:l,0);return t.earlyCol=a+1,t.es=r+1,t.ef=t.es+t.expected-1,t})})},C=new WeakSet,T=function(){let e=Math.max(...c(this,u).map(t=>c(this,o).get(t).ef)),s=new Set;c(this,d).forEach(t=>{p(this,f,v).call(this,t,"successors",s,r=>{let a=[...r.successors].map(l=>c(this,o).get(l)).reduce((l,n)=>l<n.ls?l:n.ls,e+1);return r.lf=a-1,r.ls=r.lf-r.expected+1,r.slack=r.ls-r.es,r})})};const b=[["Id","Task","Min","Likely","Max","Resources","Predecessors","Progress"]],z=[["Date","Dev 1","Dev 2","Dev 3"]],D=L(b),x=L(z),w=L({}),j=L(void 0);function y(i,e){e===void 0&&(e=navigator.languages&&navigator.languages.length?navigator.languages[0]:navigator.language);let[,s,,,,t]=1111.1.toLocaleString(e);return i=Array.from(""+i,r=>r===s?"":r===t?".":r).join(""),parseFloat(i)}D.reset=()=>D.set(b);x.reset=()=>x.set(z);w.reset=()=>w.set({});j.reset=()=>j.set(void 0);w.calculate=function(){j.set(void 0);let i;D.update(a=>(i=a,a));let e=new R;i.slice(1).forEach(a=>{e.addTask(...a)}),console.log("Starting calculation");let s=e.calc(),t=new Map;for(var r in s.map)if(Object.prototype.hasOwnProperty.call(s.map,r)){let a=s.map[r];a.predecessors=[...a.predecessors],t.set(a.id,a)}s.map=Object.fromEntries(t),console.log("Finished calculation: ",JSON.stringify(s)),w.set(s)};export{w as c,j as d,y as l,x as r,D as t};
