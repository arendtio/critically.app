import{w as u}from"./index.2391f01a.js";import{g}from"./tables.store.42dbbbd7.js";class k{constructor(){this.apiKey="",this.mediaRecorder=null,this.audioChunks=[],this.playbackAudio=null}setApiKey(e){console.log("new api key was set:",e),this.apiKey=e}async record(){if(this.apiKey=="")throw new Error("Api key not set");const e=await navigator.mediaDevices.getUserMedia({audio:!0});this.mediaRecorder=new MediaRecorder(e),this.mediaRecorder.ondataavailable=a=>{this.audioChunks.push(a.data)};let t=new Promise((a,i)=>{this.mediaRecorder.onstop=async()=>{a()}});return this.mediaRecorder.start(),t}async transcribe(){if(this.apiKey=="")throw new Error("Api key not set");const e=new Blob(this.audioChunks,{type:"audio/wav"}),t=new File([e],"recording.wav"),a=new FormData;a.append("file",t),a.append("model","whisper-1");const n=(await(await fetch("https://api.openai.com/v1/audio/transcriptions",{method:"POST",headers:{Authorization:`Bearer ${this.apiKey}`},body:a})).json()).text;return console.log("Transkribierter Text:",n),n}stopRecording(){this.mediaRecorder&&(this.mediaRecorder.stop(),this.audioChunks=[])}stopPlayback(){if(console.log("stopping audio playback"),this.playbackAudio){this.playbackAudio.pause();const e=this.playbackAudio;this.playbackAudio=null,e.onended&&e.onended()}}stop(){this.stopRecording()}async sendToGPT(e,t){if(this.apiKey=="")throw new Error("Api key not set");const a={model:"gpt-4o-mini",messages:e,tools:t};return(await(await fetch("https://api.openai.com/v1/chat/completions",{method:"POST",headers:{Authorization:`Bearer ${this.apiKey}`,"Content-Type":"application/json"},body:JSON.stringify(a)})).json()).choices[0]}async speak(e){if(this.apiKey=="")throw new Error("Api key not set");const a=await(await fetch("https://api.openai.com/v1/audio/speech",{method:"POST",headers:{Authorization:`Bearer ${this.apiKey}`,"Content-Type":"application/json"},body:JSON.stringify({input:e,model:"tts-1",voice:"shimmer"})})).blob(),i=URL.createObjectURL(a),o=new Audio(i);return this.playbackAudio=o,new Promise(n=>{o.onended=()=>{console.log("audio playback ended, revoking URL"),URL.revokeObjectURL(i),this.playbackAudio=null,n("completed")},o.addEventListener("canplaythrough",()=>{o.play().catch(s=>{console.error("Error playing audio:",s),this.playbackAudio=null,n("error")})})})}async generateTasks(e,t){console.log("Starting generate Tasks");let a=JSON.stringify(t);e.push({role:"developer",content:`This is the current task table as JSON (Array containing the rows of the table, starting with the headings):
`+a}),e.push({role:"developer",content:"Update the given task table based on the information of the last messages of the conversation. The headings should be the same. Answer just with an JSON string without any other text. Your answer must be parsable with JSON.parse(), so not even Markdown code blocks should be included."});let i=await this.sendToGPT(e);return JSON.parse(i)}async generateRessources(e,t){}}var c=new k,_=10;const l=u({isRecording:!1,isThinking:!1,isSpeaking:!1,status:"idle"}),T=u(),d=u([{role:"developer",content:"You are a helpful assistant for Project Management. Keep your answers very short. Make useful assumptions when something is undefined."},{role:"developer",content:"Use tools to plan the project. At least every "+(_-2)+" tool roundtrips you have to respond with a message to the user."},{role:"developer",content:"Dates must use the format YYYY-MM-DD."},{role:"developer",content:"Respond to the user in its prefered language. The browser tells us, that the user preferes the following language: "+(navigator.language||navigator.userLanguage)}]);let p=[];d.subscribe(r=>p=r);let m=g("tasks"),b;m.subscribe(r=>b=r);let f=g("resources"),w;f.subscribe(r=>w=r);const v=[{type:"function",strict:!0,function:{name:"operate_on_table",description:"",parameters:{type:"object",properties:{table_name:{type:"string",description:"Name of the table to be operated upon",enum:["tasks","resources"]},operation:{type:"string",description:"What operation should be performed on the table. For add_or_replace_row/add_or_replace_column, content must be an array of values for the entire row/column (including the id or heading). For change_headings, content must be an array of new headings (it must have the same length as the current headings).",enum:["add_or_replace_row","delete_row","clear_table","change_headings","add_or_replace_column"]},id:{type:"string",description:"Unique identifier of the row/column that should be affected by the operation. For add_or_replace_column, this is the column header name. If the operation is change_headings, this field is ignored."},content:{type:"array",description:"The content of one row/column of the table. It should be represented as an array of strings, which represent the columns/rows. The columns are defined by the header of the existing table. In any case, it must contain complete rows/columns and include the id or heading respectively and match the number of columns/rows of the existing table. The first value of the array must be the id or heading. If the operation is change_headings, this field should contain the new headings as an array of strings.",items:{type:"string"}}},required:["table_name","operation"],additionalProperties:!1}}}];function A(r){let e=[];return r.forEach(t=>{let a=t.function,i=t.id,o=JSON.parse(a.arguments),n;switch(o.table_name){case"tasks":n=m;break;case"resources":n=f;break;default:throw console.error("Undefined table_name was requested:",a.name,o),new Error("Undefined table_name was requested.")}switch(o.operation){case"add_or_replace_row":console.log("operation",o.operation,o),n.update(s=>(console.log("Update t",s),s.add_or_replace_row(o.id,o.content),s));break;case"delete_row":console.log("operation",o.operation,o),n.update(s=>(console.log("Update t",s),s.delete_row(o.id),s));break;case"clear_table":console.log("operation",o.operation,o),n.update(s=>(console.log("Update t",s),s.clear_table(),s));break;case"change_headings":console.log("operation",o.operation,o),n.update(s=>(console.log("Update t",s),s.changeHeadings(o.content),s));break;case"add_or_replace_column":console.log("operation",o.operation,o),n.update(s=>(console.log("Update t",s),s.add_or_replace_column(o.id,o.content),s));break;default:throw new Error("Undefined tool operation was called:",a.name,o)}e.push({role:"tool",content:"success",tool_call_id:i})}),e}async function R(r){let e=null,t=0;for(;e==null&&t<10;){let a=JSON.parse(JSON.stringify(r));a.push({role:"developer",content:"Tables are represented in JSON (an Array containing row, each row being an array itself with the columns as the fields). An empty Table always contains the first row with the headings. The first column consists of all the first fields of all the first rows."});let i=JSON.stringify(b);a.push({role:"developer",content:"About task table fields: Min, Likely and Max are estimated hours of effort to complete the task. Resources defines which resources can be used to complete the task. If multiple options exist, they can be separated by commas. If multiple resources are required together, an & can be used to connect them. The ampersand binds stringer than the comma. Predecessors is a list of Ids separated by commas which must be left empty if none is pressent. Progress is an integer between 0 and 100."}),a.push({role:"developer",content:`The current task table:
`+i});let o=JSON.stringify(w);a.push({role:"developer",content:"About resource table fields: The first column contains dates and every other column contains the available hours one ressource can work for the project."}),a.push({role:"developer",content:`The current resource table:
`+o});let n=await c.sendToGPT(a,v);console.log("response",n),d.update(s=>(s.push(n.message),s)),n.message.tool_calls!==void 0&&n.message.tool_calls.length>0&&A(n.message.tool_calls).forEach(y=>{d.update(h=>(h.push(y),h))}),t++,e=n.message.content}return e}l.record=async()=>{l.update(t=>({...t,isRecording:!0,status:"recording"})),await c.record(),l.update(t=>({...t,isRecording:!1,status:"transcribing"}));let r=await c.transcribe();d.update(t=>(t.push({role:"user",content:r}),t)),console.log("conversation:",p),l.update(t=>({...t,isThinking:!0,status:"thinking"}));let e=await R(p);if(l.update(t=>({...t,isThinking:!1})),e!=null){console.log("GPT-Antwort:",e),l.update(a=>({...a,isSpeaking:!0,status:"speaking"}));let t=await c.speak(e);console.log("the promise looks like this:",t),l.update(a=>({...a,isSpeaking:!1,status:"idle"}))}else l.update(t=>({...t,status:"idle"}))};l.stop=()=>{c.stopRecording(),l.update(r=>({...r,isRecording:!1,isThinking:!1,isSpeaking:!1,status:"idle"}))};l.stopSpeaking=()=>{c.stopPlayback()};T.subscribe(r=>{c.setApiKey(r)});export{T as a,l as b,d as c};
